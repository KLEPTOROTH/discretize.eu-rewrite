import fs from "fs";
import path from "path";

// Dynamic imports are (poorly) supported in Astro.
// Refreshing a single mdx page will cause all mdx pages to be reloaded, which will result in a massive delay.
// this script creates proxy files for all mdx files, so that mdx is imported statically and HMR works as expected.

const template = (slug) => `---
import { Content } from "@md-guides/${slug}";
import { components } from "@components/components";

// DO NOT EDIT THIS FILE !!
// This file is automatically generated by scripts/syncGuides.js
---

<Content components={components} />
`;

const dirs = [
  { astro: "src/pages/builds/", mdx: "discretize-guides/builds/" },
  { astro: "src/pages/guides/", mdx: "discretize-guides/guides/" },
  { astro: "src/pages/fractals", mdx: "discretize-guides/fractals/" },
];

// 1. clean up astro dirs
dirs
  .map(({ astro }) => astro)
  .forEach((dir) => {
    // find all subfolders in dir
    const subdirs = fs
      .readdirSync(dir)
      .filter((f) => fs.statSync(path.join(dir, f)).isDirectory());
    // delete all subfolders
    subdirs.forEach((subdir) =>
      fs.rmSync(path.join(dir, subdir), { recursive: true }, () => {})
    );
  });

// 2. create new proxy files
function copyFolderRecursive(source, destination) {
  if (!fs.existsSync(destination)) {
    fs.mkdirSync(destination);
  }

  const files = fs.readdirSync(source);

  files.forEach((file) => {
    const sourcePath = path.join(source, file);
    const destinationPath = path.join(
      destination,
      file.replace(".mdx", ".astro")
    );

    if (fs.lstatSync(sourcePath).isDirectory()) {
      copyFolderRecursive(sourcePath, destinationPath);
    } else {
      if (file.endsWith(".mdx")) {
        const slug = sourcePath.replace("discretize-guides/", "");
        fs.writeFileSync(destinationPath, template(slug));
      }
    }
  });
}

dirs.forEach(({ astro, mdx }) => {
  copyFolderRecursive(mdx, astro);
});
